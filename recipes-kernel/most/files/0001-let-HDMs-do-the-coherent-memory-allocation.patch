From b4fe384dde3e230d8c252525fcd5297015b147d1 Mon Sep 17 00:00:00 2001
From: Christian Gromm <christian.gromm@microchip.com>
Date: Wed, 2 Aug 2017 14:51:20 +0200
Subject: [PATCH 1/5] let HDMs do the coherent memory allocation

On arm64/aarch64 architectures the allocation of coherent memory
needs a device that has the dma_ops proberly set. That's why the
core module of the MOST driver is no longer able to allocate this
kind of memory. This patch moves the allocation process down to
the HDM layer where the proper devices exist in either the USB
host controller or the platform device.

Signed-off-by: Christian Gromm <christian.gromm@microchip.com>


Signed-off-by: Christian Gromm <christian.gromm@microchip.com>
---
 driver/hdm-dim2/dim2_hdm.c | 12 ++++++++++++
 driver/hdm-usb/hdm_usb.c   | 18 ++++++++++++++++++
 driver/include/mostcore.h  |  2 ++
 driver/mostcore/core.c     | 17 +++++++++++------
 4 files changed, 43 insertions(+), 6 deletions(-)

diff --git a/hdm-dim2/dim2_hdm.c b/hdm-dim2/dim2_hdm.c
index 35aee9f..1b164cf 100644
--- a/hdm-dim2/dim2_hdm.c
+++ b/hdm-dim2/dim2_hdm.c
@@ -722,6 +722,16 @@ static int poison_channel(struct most_interface *most_iface, int ch_idx)
 	return ret;
 }
 
+static void *dma_alloc(struct mbo *mbo, u32 size)
+{
+	return dma_alloc_coherent(NULL, size, &mbo->bus_address, GFP_KERNEL);
+}
+
+static void dma_free(struct mbo *mbo, u32 size)
+{
+	dma_free_coherent(NULL, size, mbo->virt_address, mbo->bus_address);
+}
+
 /*
  * dim2_probe - dim2 probe handler
  * @pdev: platform device structure
@@ -820,6 +830,8 @@ static int dim2_probe(struct platform_device *pdev)
 	dev->most_iface.channel_vector = dev->capabilities;
 	dev->most_iface.configure = configure_channel;
 	dev->most_iface.enqueue = enqueue;
+	dev->most_iface.dma_alloc = dma_alloc;
+	dev->most_iface.dma_free = dma_free;
 	dev->most_iface.poison_channel = poison_channel;
 	dev->most_iface.request_netinfo = request_netinfo;
 
diff --git a/hdm-usb/hdm_usb.c b/hdm-usb/hdm_usb.c
index 3433646..0b689b5 100644
--- a/hdm-usb/hdm_usb.c
+++ b/hdm-usb/hdm_usb.c
@@ -629,6 +629,22 @@ _error:
 	return retval;
 }
 
+static void *hdm_dma_alloc(struct mbo *mbo, u32 size)
+{
+	struct most_dev *mdev = to_mdev(mbo->ifp);
+
+	return usb_alloc_coherent(mdev->usb_device, size, GFP_KERNEL,
+				  &mbo->bus_address);
+}
+
+static void hdm_dma_free(struct mbo *mbo, u32 size)
+{
+	struct most_dev *mdev = to_mdev(mbo->ifp);
+
+	usb_free_coherent(mdev->usb_device, size, mbo->virt_address,
+			  mbo->bus_address);
+}
+
 /**
  * hdm_configure_channel - receive channel configuration from core
  * @iface: interface
@@ -1140,6 +1156,8 @@ hdm_probe(struct usb_interface *interface, const struct usb_device_id *id)
 	mdev->iface.request_netinfo = hdm_request_netinfo;
 	mdev->iface.enqueue = hdm_enqueue;
 	mdev->iface.poison_channel = hdm_poison_channel;
+	mdev->iface.dma_alloc = hdm_dma_alloc;
+	mdev->iface.dma_free = hdm_dma_free;
 	mdev->iface.description = mdev->description;
 	mdev->iface.num_channels = num_endpoints;
 
diff --git a/include/mostcore.h b/include/mostcore.h
index 5f8339b..deefe25 100644
--- a/include/mostcore.h
+++ b/include/mostcore.h
@@ -241,6 +241,8 @@ struct most_interface {
 	const char *description;
 	int num_channels;
 	struct most_channel_capability *channel_vector;
+	void *(*dma_alloc)(struct mbo *mbo, u32 size);
+	void (*dma_free)(struct mbo *mbo, u32 size);
 	int (*configure)(struct most_interface *iface, int channel_idx,
 			 struct most_channel_config *channel_config);
 	int (*enqueue)(struct most_interface *iface, int channel_idx,
diff --git a/mostcore/core.c b/mostcore/core.c
index 4c580d1..931efb9 100644
--- a/mostcore/core.c
+++ b/mostcore/core.c
@@ -184,8 +184,10 @@ static void most_free_mbo_coherent(struct mbo *mbo)
 	struct most_c_obj *c = mbo->context;
 	u16 const coherent_buf_size = c->cfg.buffer_size + c->cfg.extra_len;
 
-	dma_free_coherent(NULL, coherent_buf_size, mbo->virt_address,
-			  mbo->bus_address);
+	if (c->iface->dma_free)
+		c->iface->dma_free(mbo, coherent_buf_size);
+	else
+		kfree(mbo->virt_address);
 	kfree(mbo);
 	if (atomic_sub_and_test(1, &c->mbo_ref))
 		complete(&c->cleanup);
@@ -1289,10 +1291,13 @@ static int arm_mbo_chain(struct most_c_obj *c, int dir,
 		mbo->context = c;
 		mbo->ifp = c->iface;
 		mbo->hdm_channel_id = c->channel_id;
-		mbo->virt_address = dma_alloc_coherent(NULL,
-						       coherent_buf_size,
-						       &mbo->bus_address,
-						       GFP_KERNEL);
+		if (c->iface->dma_alloc) {
+			mbo->virt_address =
+				c->iface->dma_alloc(mbo, coherent_buf_size);
+		} else {
+			mbo->virt_address =
+				kzalloc(coherent_buf_size, GFP_KERNEL);
+		}
 		if (!mbo->virt_address) {
 			pr_info("WARN: No DMA coherent buffer.\n");
 			retval = i;
-- 
2.7.4

